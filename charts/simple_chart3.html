<!DOCTYPE html>
<html>
<head>
    <title>BNB Renko Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        .chart-container {
            position: relative;
            width: 90%;
            height: 600px;
            margin: 20px auto;
        }
        canvas {
            background-color: #1a1a1a;
        }
    </style>
</head>
<body style="background-color: #1a1a1a; color: #ffffff;">
    <div class="chart-container">
        <canvas id="renkoChart"></canvas>
        <div id="summary" style="margin-top: 20px; font-family: monospace;"></div>
    </div>

    <script type="module">
        // Create tooltip element
        function getOrCreateTooltip(chart) {
            let tooltipEl = document.getElementById('chartjs-tooltip');
            if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.id = 'chartjs-tooltip';
                tooltipEl.style.background = 'rgba(0, 0, 0, 0.8)';
                tooltipEl.style.borderRadius = '3px';
                tooltipEl.style.color = 'white';
                tooltipEl.style.opacity = 0;
                tooltipEl.style.pointerEvents = 'none';
                tooltipEl.style.position = 'absolute';
                tooltipEl.style.transform = 'translate(-50%, 0)';
                tooltipEl.style.transition = 'all .1s ease';
                tooltipEl.style.border = '1px solid #666';
                
                chart.canvas.parentNode.appendChild(tooltipEl);
            }
            return tooltipEl;
        }

        import {  renkoBlockSize } from '../config/config.js';
        
        let wsPrice = null;
        let chart = null;
        const WS_URL = 'wss://stream.bybit.com/v5/public/linear';
        
        // Connect to WebSocket
        function connectWebSocket() {
            const ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                console.log('Connected to Bybit WebSocket');
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: [`tickers.${symbol}`]
                }));
            };
            
            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.topic === `tickers.${symbol}` && message.data && message.data.lastPrice) {
                        wsPrice = parseFloat(message.data.lastPrice);
                        if (chart && chart.ctx) {
                            requestAnimationFrame(() => {
                                if (chart.ctx) {
                                    chart.update('none');
                                    console.log('Price updated:', wsPrice);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error processing message:', error);
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected. Reconnecting...');
                setTimeout(connectWebSocket, 5000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                ws.close();
            };
        }
        
        // Start WebSocket connection after a short delay to ensure chart is initialized
        setTimeout(connectWebSocket, 1000);

        import { getCandles as getBinanceCandles } from '../apis/binance.js';
        import { getCandles as getBybitCandles } from '../apis/bybit.js';
        import { api, time, symbol, limit, delay } from '../config/config.js';
        const getCandles = api === 'binance' ? getBinanceCandles : getBybitCandles;
        
        // Function to create Renko blocks from price data with fixed USDT block size
        function createRenkoBlocks(data, blockSizeUSDT) {
            console.log('Creating Renko blocks with data:', data[0], 'Block size:', blockSizeUSDT, 'USDT');
            const blocks = [];
            let lastBlockStartTime = data[0].time;
            let currentPrice = parseFloat(data[0].close);
            let lastDirection = null;
            let highest = { diff: 0, time: null };
            let timeSpan = null;

            for (let i = 0; i < data.length; i++) {
                const price = parseFloat(data[i].close);
                const priceDiff = price - currentPrice;
                const direction = priceDiff >= 0 ? 1 : -1;

                if (Math.abs(priceDiff) > highest.diff) {
                    highest = { diff: Math.abs(priceDiff), time: data[i].time };
                }

                if (i === data.length - 1) {
                    const firstDate = new Date(data[0].time);
                    const lastDate = new Date(data[i].time);
                    const timeDiff = lastDate - firstDate;
                    const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                    timeSpan = `${days}d ${hours}h ${minutes}m`;
                }

                // Check if price movement is enough to create new block(s)
                if (Math.abs(priceDiff) >= blockSizeUSDT) {
                    const numBlocks = Math.floor(Math.abs(priceDiff) / blockSizeUSDT);
                    
                    for (let j = 0; j < numBlocks; j++) {
                        const blockOpen = currentPrice;
                        const blockClose = currentPrice + (direction * blockSizeUSDT);
                        
                        blocks.push({
                            startTime: lastBlockStartTime,
                            endTime: data[i].time,
                            time: data[i].time,
                            open: blockOpen,
                            close: blockClose,
                            direction: direction,
                            isNewTrend: lastDirection !== null && direction !== lastDirection
                        });
                        
                        currentPrice = blockClose;
                        lastDirection = direction;
                        lastBlockStartTime = data[i].time;
                    }
                }
            }

            document.getElementById('summary').innerHTML = 
                `<span style="color: #44ff44"><strong>Time Span:</strong> ${timeSpan}</span><br>` +
                `<span style="color: #ff4444"><strong>Highest Move:</strong> ${highest.diff}% at ${highest.time}</span><br>`;

            console.log('Created blocks:', blocks.length);
            return blocks;
        }

        async function updateChart() {
            const endTime = Date.now() - (delay * 60 * 1000);
            const candles = await getCandles(symbol, time, limit, endTime);
            
            // Sort candles by timestamp
            candles.sort((a, b) => new Date(a.time) - new Date(b.time));

            console.log('Raw candles:', candles.length, 'Sample:', candles[0]);
            // Create Renko blocks with fixed USDT block size from config
            const renkoBlocks = createRenkoBlocks(candles, renkoBlockSize);
            console.log('Generated Renko blocks:', renkoBlocks.length);

            // Prepare data for custom Renko display
            // Calculate dynamic block width based on available space
            const calculateBlockDimensions = (chartArea, numBlocks) => {
                const minBlockWidth = 15; // Minimum block width
                const maxBlockWidth = 30; // Maximum block width
                const minSpacing = 1;     // Minimum spacing
                const maxSpacing = 3;     // Maximum spacing

                // Calculate available width per block
                const availableWidth = chartArea.right - chartArea.left;
                let blockWidth = Math.floor(availableWidth / (numBlocks + 5)) - 2; // Add 5 for padding

                // Constrain block width
                blockWidth = Math.max(minBlockWidth, Math.min(blockWidth, maxBlockWidth));
                
                // Adjust spacing based on block width
                const spacing = Math.max(minSpacing, Math.min(maxSpacing, blockWidth * 0.1));

                return { blockWidth, spacing };
            };

            // Create custom plugin for Renko blocks and latest price
            let activeTooltip = null;

            const renkoPlugin = {
                id: 'renkoBlocks',
                beforeDraw: (chart, args, options) => {
                    const canvas = chart.canvas;
                    if (!canvas.onmousemove) {
                        canvas.onmousemove = function(e) {
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            const {ctx, chartArea, scales} = chart;

                            // Calculate block dimensions
                            const { blockWidth, spacing } = calculateBlockDimensions(chartArea, renkoBlocks.length);

                            // Check if mouse is over a block
                            let foundBlock = false;
                            renkoBlocks.forEach((block, i) => {
                                const blockX = chartArea.left + (i * (blockWidth + spacing));
                                const blockY = scales.y.getPixelForValue(block.close);
                                const blockHeight = Math.abs(scales.y.getPixelForValue(block.open) - blockY);
                                const blockTop = Math.min(blockY, scales.y.getPixelForValue(block.open));

                                if (x >= blockX && x <= blockX + blockWidth &&
                                    y >= blockTop && y <= blockTop + blockHeight) {
                                    // Show tooltip
                                    const tooltipEl = getOrCreateTooltip(chart);
                                    const time = new Date(block.time).toLocaleString('en-US', {
                                        weekday: 'short',
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: true
                                    });
                                    const move = block.close - block.open;
                                    const moveBlocks = Math.abs(move) / renkoBlockSize;

                                    tooltipEl.style.opacity = 1;
                                    tooltipEl.style.left = blockX + blockWidth + 5 + 'px';
                                    tooltipEl.style.top = blockTop + 'px';
                                    // Calculate duration
                                    const startTime = typeof block.startTime === 'number' ? block.startTime : new Date(block.startTime).getTime();
                                    const endTime = typeof block.endTime === 'number' ? block.endTime : new Date(block.endTime).getTime();
                                    const durationMs = endTime - startTime;
                                    const hours = Math.floor(durationMs / (1000 * 60 * 60));
                                    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
                                    const durationText = hours > 0 ? 
                                        `${hours}h ${minutes}m` : 
                                        minutes > 0 ? `${minutes}m` : '< 1m';
                                    console.log('Block duration:', { 
                                        startTime: new Date(startTime).toISOString(),
                                        endTime: new Date(endTime).toISOString(),
                                        durationMs, 
                                        hours, 
                                        minutes 
                                    });

                                    tooltipEl.innerHTML = `
                                        <div style="padding: 8px; color: #fff;">
                                            <div>Time: ${time}</div>
                                            <div>Duration: ${durationText}</div>
                                            <div>Open: $${block.open.toFixed(4)}</div>
                                            <div>Close: $${block.close.toFixed(4)}</div>
                                            <div>Move: $${Math.abs(move).toFixed(2)} (${moveBlocks} blocks)</div>
                                            <div>Direction: ${move > 0 ? '▲ Up' : '▼ Down'}</div>
                                        </div>
                                    `;
                                    activeTooltip = tooltipEl;
                                    foundBlock = true;
                                }
                            });

                            if (!foundBlock && activeTooltip) {
                                activeTooltip.style.opacity = 0;
                                activeTooltip = null;
                            }
                        };

                        canvas.onmouseleave = function() {
                            if (activeTooltip) {
                                activeTooltip.style.opacity = 0;
                                activeTooltip = null;
                            }
                        };
                    }
                    const {ctx, chartArea, scales} = chart;
                    const blocks = renkoBlocks;
                    const latestPrice = parseFloat(candles[candles.length - 1].close);

                    // Calculate dynamic dimensions
                    const { blockWidth, spacing } = calculateBlockDimensions(chartArea, blocks.length);

                    blocks.forEach((block, i) => {
                        const x = chartArea.left + (i * (blockWidth + spacing));
                        const y = scales.y.getPixelForValue(block.close);
                        const height = Math.abs(scales.y.getPixelForValue(block.open) - y);

                        // Draw block
                        ctx.fillStyle = block.direction > 0 ? '#00ff88' : '#ff4444';
                        ctx.fillRect(x, Math.min(y, scales.y.getPixelForValue(block.open)), blockWidth, height);

                        // Draw trend change indicator
                        if (block.isNewTrend) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x, Math.min(y, scales.y.getPixelForValue(block.open)), blockWidth, height);
                        }

                        // Add block size indicator for multi-block moves
                        const move = Math.abs(block.close - block.open);
                        const blocks = move / renkoBlockSize;
                        if (blocks > 1) {
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(blocks.toString(), x + blockWidth/2, Math.min(y, scales.y.getPixelForValue(block.open)) + height/2);
                        }
                    });

                    // Draw latest price line using WebSocket price if available
                    if (wsPrice || (candles && candles.length > 0)) {
                        const latestPrice = wsPrice || parseFloat(candles[candles.length - 1].close);
                        console.log('Drawing price line:', latestPrice);
                        const y = scales.y.getPixelForValue(latestPrice);
                        
                        // Only draw if price is within visible area
                        if (y >= chartArea.top && y <= chartArea.bottom) {
                            // Draw background line for visibility
                            ctx.beginPath();
                            ctx.moveTo(chartArea.left, y);
                            ctx.lineTo(chartArea.right, y);
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 4;
                            ctx.stroke();

                            // Draw yellow line
                            ctx.beginPath();
                            ctx.moveTo(chartArea.left, y);
                            ctx.lineTo(chartArea.right, y);
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 3]);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Add price label with background
                            const priceText = `$${latestPrice.toFixed(4)}`;
                            ctx.font = 'bold 12px Arial';
                            const textWidth = ctx.measureText(priceText).width;
                            const padding = 4;
                            
                            // Draw label background
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(
                                chartArea.left + 5,
                                y - 16,
                                textWidth + (padding * 2),
                                20
                            );

                            // Draw text
                            ctx.fillStyle = '#ffff00';
                            ctx.textAlign = 'left';
                            ctx.fillText(priceText, chartArea.left + 5 + padding, y - 2);
                        }
                    }
                }
            };

            // Create dataset for price scale
            const dataset = {
                label: 'Renko',
                data: renkoBlocks.map((block, i) => ({
                    x: i,
                    y: block.close,
                    time: block.time,
                    open: block.open,
                    close: block.close,
                    direction: block.direction
                })),
                borderColor: 'rgba(0,0,0,0)',
                pointRadius: 0
            };

            // Create chart
            const ctx = document.getElementById('renkoChart').getContext('2d');
            
            // Properly destroy existing chart
            if (chart instanceof Chart) {
                chart.destroy();
            }
            
            // Clear any existing Chart instances from the canvas
            Chart.getChart(ctx.canvas)?.destroy();
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Renko',
                        data: renkoBlocks.map((block, i) => ({
                            x: i,
                            y: block.close
                        })),
                        borderColor: 'rgba(0,0,0,0)',
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    layout: {
                        padding: {
                            left: 20,   // Add padding for price labels
                            right: 50,  // Add padding for last blocks
                            top: 20,    // Add padding for price labels
                            bottom: 20  // Add padding for labels
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            grid: {
                                color: '#333333'
                            },
                            ticks: {
                                color: '#ffffff',
                                stepSize: 1, // You can adjust this value to change the price increment scale
                                callback: function(value) {
                                    return value.toFixed(4);
                                }
                            },
                            beginAtZero: false
                        },
                        x: {
                            type: 'linear',
                            grid: {
                                display: false
                            },
                            ticks: {
                                display: false
                            },
                            offset: true,  // Offset the axis to show full blocks
                            min: -2,      // Add space at start
                            max: renkoBlocks.length + 2  // Add space at end
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false,
                            callbacks: {
                                label: function(context) {
                                    const block = context.raw.block;
                                    if (!block) return [];
                                    
                                    const move = block.close - block.open;
                                    const moveBlocks = Math.abs(move) / renkoBlockSize;
                                    const time = new Date(block.time).toLocaleString('en-US', {
                                        weekday: 'short',
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: true
                                    });
                                    
                                    return [
                                        `Time: ${time}`,
                                        `Open: $${block.open.toFixed(4)}`,
                                        `Close: $${block.close.toFixed(4)}`,
                                        `Move: $${Math.abs(move).toFixed(2)} (${moveBlocks} blocks)`,
                                        `Direction: ${move > 0 ? '▲ Up' : '▼ Down'}`
                                    ];
                                }
                            }
                        },
                        renkoBlocks: {}
                    }
                },
                plugins: [renkoPlugin]
            });
        }

        // Update every minute
        let updateInterval;
        
        async function startUpdates() {
            // Clear any existing interval
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            
            // Initial update
            await updateChart();
            
            // Set new interval
            updateInterval = setInterval(updateChart, 60000);
        }
        
        // Start updates
        startUpdates();
    </script>
</body>
</html>
