<!DOCTYPE html>
<html>
<head>
    <title>BNB Close-to-Close Movement Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body style="background-color: #1a1a1a; color: #ffffff;">
    <div style="width: 90%; margin: 20px auto;">
        <canvas id="priceChart"></canvas>
        <div id="summary" style="margin-top: 20px; font-family: monospace;"></div>
    </div>

    <script type="module">
        import { getCandles as getBinanceCandles } from './binance.js';
        import { getCandles as getBybitCandles } from './bybit.js';
        import { api, delay } from './config.js';
        
        // Select API based on config
        const getCandles = api === 'binance' ? getBinanceCandles : getBybitCandles;
        import { time, symbol, limit, mediumPercentile, highPercentile, lowPercentile } from './config.js';

        async function updateChart() {
            const candles = await getCandles(symbol, time, limit);
            
            // Apply delay by removing most recent candles
            const delayedCandles = delay > 0 ? candles.slice(0, -delay) : candles;
            
            // Sort candles by timestamp in ascending order
            delayedCandles.sort((a, b) => new Date(a.time) - new Date(b.time));
            
            const data = delayedCandles.map((c, index) => {
                const prevCandle = index > 0 ? delayedCandles[index - 1] : c;
                return {
                    time: new Date(c.time).toLocaleTimeString(),
                    diff: ((c.close - prevCandle.close) / prevCandle.close * 100).toFixed(2),
                    close: parseFloat(c.close),
                    prevClose: parseFloat(prevCandle.close)
                };
            });

            const times = data.map(d => d.time);
            const diffs = data.map(d => parseFloat(d.diff));

            // Calculate averages
            const sortedDiffs = [...diffs].sort((a, b) => a - b);
            const avgDiff = (diffs.reduce((sum, val) => sum + val, 0) / diffs.length).toFixed(2);
            const lowAvg = sortedDiffs[Math.floor(sortedDiffs.length * lowPercentile)].toFixed(2);
            const mediumAvg = sortedDiffs[Math.floor(sortedDiffs.length * mediumPercentile)].toFixed(2);
            const highAvg = sortedDiffs[Math.floor(sortedDiffs.length * highPercentile)].toFixed(2);

            // Find highest and lowest
            const highest = data.reduce((max, curr) => 
                parseFloat(curr.diff) > parseFloat(max.diff) ? curr : max
            );
            const lowest = data.reduce((min, curr) => 
                parseFloat(curr.diff) < parseFloat(min.diff) ? min : min
            );

            // Calculate total average price and spreads
            const totalAvg = (data.reduce((sum, d) => sum + d.close, 0) / data.length).toFixed(2);
            const highLowSpread = (parseFloat(highAvg) - parseFloat(lowAvg)).toFixed(2);

            // Count corrections and full reversals
            let highMoves = 0;
            let corrections = 0;
            let inHighMove = false;
            
            // For full reversals
            let upMoves = 0;
            let downMoves = 0;
            let fullReversalsUp = 0;    // Down to Up
            let fullReversalsDown = 0;   // Up to Down
            let lastExtremeMove = null;  // 'up' or 'down'

            data.forEach(d => {
                const diff = parseFloat(d.diff);
                
                // Track normal corrections
                if (diff >= parseFloat(highAvg)) {
                    if (!inHighMove) {
                        highMoves++;
                        inHighMove = true;
                    }
                } else if (diff <= parseFloat(avgDiff) && inHighMove) {
                    corrections++;
                    inHighMove = false;
                }
                
                // Track full reversals
                if (diff >= parseFloat(highAvg)) {
                    if (lastExtremeMove === 'down') {
                        fullReversalsUp++;
                    }
                    lastExtremeMove = 'up';
                    upMoves++;
                } else if (diff <= -parseFloat(highAvg)) {
                    if (lastExtremeMove === 'up') {
                        fullReversalsDown++;
                    }
                    lastExtremeMove = 'down';
                    downMoves++;
                }
            });

            const correctionRate = ((corrections / highMoves) * 100).toFixed(1);
            const totalReversals = fullReversalsUp + fullReversalsDown;
            const totalExtremeMoves = upMoves + downMoves;
            const fullReversalRate = ((totalReversals / totalExtremeMoves) * 100).toFixed(1);

            // Update summary
            document.getElementById('summary').innerHTML = 
                `<span style="color: #ff4444"><strong>Highest Move:</strong> ${highest.diff}% at ${highest.time}</span><br>` +
                `<span style="color: #4444ff"><strong>Lowest Move:</strong> ${lowest.diff}% at ${lowest.time}</span><br>` +
                `<span style="color: #4488ff"><strong>Low Band:</strong> ${lowAvg}%</span><br>` +
                `<span style="color: #00ff88"><strong>Average Move:</strong> ${avgDiff}%</span><br>` +
                `<span style="color: #ffff00"><strong>Medium Band:</strong> ${mediumAvg}%</span><br>` +
                `<span style="color: #ff0000"><strong>High Band:</strong> ${highAvg}%</span><br>` +
                `<span style="color: #ff88ff"><strong>Band Spread:</strong> ${highLowSpread}%</span><br>` +
                `<span style="color: #ff88ff"><strong>Correction Rate:</strong> ${correctionRate}%</span><br>` +
                `<span style="color: #ff44ff"><strong>Full Reversal Rate:</strong> ${fullReversalRate}% (${totalReversals}/${totalExtremeMoves})</span><br>` +
                `<span style="color: #ff44ff"><strong>Up→Down:</strong> ${fullReversalsDown} | <strong>Down→Up:</strong> ${fullReversalsUp}</span><br>` +
                `<span style="color: #00ff88"><strong>Average Price:</strong> $${totalAvg}</span>`;

            // Create new chart
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (window.myChart) {
                window.myChart.destroy();
            }

            window.myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: times,
                    datasets: [{
                        label: 'Price Movement %',
                        data: diffs,
                        borderColor: '#00ff88',
                        tension: 0.1,
                        pointBackgroundColor: function(context) {
                            const diff = context.raw;
                            if (Math.abs(diff) >= parseFloat(highAvg)) return '#ff0000';
                            if (Math.abs(diff) >= parseFloat(mediumAvg)) return '#ffff00';
                            return '#00ff88';
                        },
                        pointRadius: function(context) {
                            const diff = context.raw;
                            if (Math.abs(diff) >= parseFloat(highAvg)) return 6;
                            if (Math.abs(diff) >= parseFloat(mediumAvg)) return 5;
                            return 3;
                        }
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return [
                                        `Movement: ${context.raw}%`,
                                        `Close: $${data[context.dataIndex].close.toFixed(4)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                highLine: {
                                    type: 'line',
                                    yMin: highAvg,
                                    yMax: highAvg,
                                    borderColor: '#ff0000',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                highLineNeg: {
                                    type: 'line',
                                    yMin: -highAvg,
                                    yMax: -highAvg,
                                    borderColor: '#ff0000',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                mediumLine: {
                                    type: 'line',
                                    yMin: mediumAvg,
                                    yMax: mediumAvg,
                                    borderColor: '#ffff00',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                mediumLineNeg: {
                                    type: 'line',
                                    yMin: -mediumAvg,
                                    yMax: -mediumAvg,
                                    borderColor: '#ffff00',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                lowLine: {
                                    type: 'line',
                                    yMin: lowAvg,
                                    yMax: lowAvg,
                                    borderColor: '#4488ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                lowLineNeg: {
                                    type: 'line',
                                    yMin: -lowAvg,
                                    yMax: -lowAvg,
                                    borderColor: '#4488ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                zeroLine: {
                                    type: 'line',
                                    yMin: 0,
                                    yMax: 0,
                                    borderColor: '#666666',
                                    borderWidth: 1
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            grid: {
                                color: '#333333'
                            },
                            ticks: {
                                color: '#ffffff',
                                stepSize: 0.001
                            }
                        },
                        x: {
                            grid: {
                                color: '#333333'
                            },
                            ticks: {
                                color: '#ffffff',
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        }

        // Update every minute
        updateChart();
        setInterval(updateChart, 60000);
    </script>
</body>
</html>
