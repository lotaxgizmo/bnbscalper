<!DOCTYPE html>
<html>
<head>
    <title>BNB Close-to-Close Movement Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body style="background-color: #1a1a1a; color: #ffffff;">
    <div style="width: 90%; margin: 20px auto;">
        <div style="margin-bottom: 10px;">
            <button id="timeFormatToggle" style="background: #333; color: #fff; border: 1px solid #666; padding: 5px 10px; cursor: pointer; border-radius: 4px;">Switch to 24h Format</button>
        </div>
        <canvas id="priceChart"></canvas>
        <div id="summary" style="margin-top: 20px; font-family: monospace;"></div>
    </div>

    <script type="module">
        // Initialize time format preference
        let use24Hour = false;
        const savedFormat = localStorage.getItem('timeFormat');
        if (savedFormat) {
            use24Hour = savedFormat === '24h';
            document.getElementById('timeFormatToggle').textContent = use24Hour ? 'Switch to 12h Format' : 'Switch to 24h Format';
        }

        // Time format toggle handler
        document.getElementById('timeFormatToggle').addEventListener('click', function() {
            use24Hour = !use24Hour;
            localStorage.setItem('timeFormat', use24Hour ? '24h' : '12h');
            this.textContent = use24Hour ? 'Switch to 12h Format' : 'Switch to 24h Format';
            updateChart();
        });

        import { getCandles as getBinanceCandles } from './binance.js';
        import { getCandles as getBybitCandles } from './bybit.js';
        import { api, delay, pricePercentile } from './config.js';
        
        // Select API based on config
        const getCandles = api === 'binance' ? getBinanceCandles : getBybitCandles;
        import { time, symbol, limit, mediumPercentile, highPercentile, lowPercentile, topPercentile } from './config.js';

        async function updateChart() {
            // Calculate end time by subtracting delay minutes from current time
            const endTime = Date.now() - (delay * 60 * 1000); // delay is in minutes
            const candles = await getCandles(symbol, time, limit, endTime);
            
            // Sort candles by timestamp in ascending order
            candles.sort((a, b) => new Date(a.time) - new Date(b.time));
            
            const data = candles.map((c, index) => {
                const prevCandle = index > 0 ? candles[index - 1] : c;
                return {
                    time: new Date(c.time).toLocaleString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: !use24Hour
                }),
                    diff: ((c.close - prevCandle.close) / prevCandle.close * 100).toFixed(2),
                    close: parseFloat(c.close),
                    prevClose: parseFloat(prevCandle.close)
                };
            });

            const times = data.map(d => d.time);
            const diffs = data.map(d => parseFloat(d.diff));

            // Calculate time span
            const firstDate = new Date(candles[0].time);
            const lastDate = new Date(candles[candles.length - 1].time);
            const timeDiff = lastDate - firstDate;
            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
            const timeSpan = `${days}d ${hours}h ${minutes}m`;

            // Calculate averages
            const sortedDiffs = [...diffs].sort((a, b) => a - b);
            const avgDiff = (diffs.reduce((sum, val) => sum + val, 0) / diffs.length).toFixed(2);
            const lowAvg = sortedDiffs[Math.floor(sortedDiffs.length * lowPercentile)].toFixed(2);
            const mediumAvg = sortedDiffs[Math.floor(sortedDiffs.length * mediumPercentile)].toFixed(2);
            const highAvg = sortedDiffs[Math.floor(sortedDiffs.length * highPercentile)].toFixed(2);
            const topAvg = sortedDiffs[Math.floor(sortedDiffs.length * topPercentile)].toFixed(2);

            // Find highest and lowest
            const highest = data.reduce((max, curr) => 
                parseFloat(curr.diff) > parseFloat(max.diff) ? curr : max
            );
            const lowest = data.reduce((min, curr) => 
                parseFloat(curr.diff) < parseFloat(min.diff) ? min : min
            );

            // Calculate total average price and spreads
            const totalAvg = (data.reduce((sum, d) => sum + d.close, 0) / data.length).toFixed(2);
            const highLowSpread = (parseFloat(highAvg) - parseFloat(lowAvg)).toFixed(2);

            // Count corrections and full reversals
            let highMoves = 0;
            let corrections = 0;
            let inHighMove = false;
            
            // For full reversals
            let upMoves = 0;
            let downMoves = 0;
            let fullReversalsUp = 0;    // Down to Up
            let fullReversalsDown = 0;   // Up to Down
            let lastExtremeMove = null;  // 'up' or 'down'

            data.forEach(d => {
                const diff = parseFloat(d.diff);
                
                // Track normal corrections
                if (diff >= parseFloat(highAvg)) {
                    if (!inHighMove) {
                        highMoves++;
                        inHighMove = true;
                    }
                } else if (diff <= parseFloat(avgDiff) && inHighMove) {
                    corrections++;
                    inHighMove = false;
                }
                
                // Track full reversals
                if (diff >= parseFloat(highAvg)) {
                    if (lastExtremeMove === 'down') {
                        fullReversalsUp++;
                    }
                    lastExtremeMove = 'up';
                    upMoves++;
                } else if (diff <= -parseFloat(highAvg)) {
                    if (lastExtremeMove === 'up') {
                        fullReversalsDown++;
                    }
                    lastExtremeMove = 'down';
                    downMoves++;
                }
            });

            const correctionRate = ((corrections / highMoves) * 100).toFixed(1);
            const totalReversals = fullReversalsUp + fullReversalsDown;
            const totalExtremeMoves = upMoves + downMoves;
            const fullReversalRate = ((totalReversals / totalExtremeMoves) * 100).toFixed(1);

            // Update summary
            document.getElementById('summary').innerHTML = 
                `<span style="color: #44ff44"><strong>Time Span:</strong> ${timeSpan}</span><br>` +
                `<span style="color: #ff4444"><strong>Highest Move:</strong> ${highest.diff}% at ${highest.time}</span><br>` +
                `<span style="color: #4444ff"><strong>Lowest Move:</strong> ${lowest.diff}% at ${lowest.time}</span><br>` +
                `<span style="color: #4488ff"><strong>Low Band:</strong> ${lowAvg}%</span><br>` +
                `<span style="color: #00ff88"><strong>Average Move:</strong> ${avgDiff}%</span><br>` +
                `<span style="color: #ff00ff"><strong>Top Band:</strong> ${topAvg}%</span><br>` +
                `<span style="color: #ffff00"><strong>Medium Band:</strong> ${mediumAvg}%</span><br>` +
                `<span style="color: #ff0000"><strong>High Band:</strong> ${highAvg}%</span><br>` +
                `<span style="color: #ff88ff"><strong>Band Spread:</strong> ${highLowSpread}%</span><br>` +
                `<span style="color: #ff88ff"><strong>Correction Rate:</strong> ${correctionRate}%</span><br>` +
                `<span style="color: #ff44ff"><strong>Full Reversal Rate:</strong> ${fullReversalRate}% (${totalReversals}/${totalExtremeMoves})</span><br>` +
                `<span style="color: #ff44ff"><strong>Up→Down:</strong> ${fullReversalsDown} | <strong>Down→Up:</strong> ${fullReversalsUp}</span><br>` +
                `<span style="color: #00ff88"><strong>Average Price:</strong> $${totalAvg}</span>`;

            // Create new chart
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (window.myChart) {
                window.myChart.destroy();
            }

            window.myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: times,
                    datasets: [{
                        label: 'Price Movement %',
                        data: diffs,
                        borderColor: '#00ff88',
                        tension: 0.1,
                        pointBackgroundColor: function(context) {
                            const diff = context.raw;
                            if (Math.abs(diff) >= parseFloat(topAvg)) return '#ff00ff';
                            if (Math.abs(diff) >= parseFloat(highAvg)) return '#ff0000';
                            if (Math.abs(diff) >= parseFloat(mediumAvg)) return '#ffff00';
                            return '#00ff88';
                        },
                        pointRadius: function(context) {
                            const diff = context.raw;
                            if (Math.abs(diff) >= parseFloat(topAvg)) return 7;
                            if (Math.abs(diff) >= parseFloat(highAvg)) return 6;
                            if (Math.abs(diff) >= parseFloat(mediumAvg)) return 5;
                            return 3;
                        }
                    },
                    {
                        label: 'Price',
                        data: data.map(d => parseFloat(d.close)),
                        borderColor: '#00ffff',
                        borderWidth: 3,
                        pointRadius: 3,
                        tension: 0.1,
                        yAxisID: 'price'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label === 'Price') {
                                        return `Price: $${context.raw.toFixed(4)}`;
                                    }
                                    return [
                                        `Movement: ${context.raw}%`,
                                        `Close: $${data[context.dataIndex].close.toFixed(4)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                topLine: {
                                    type: 'line',
                                    yMin: topAvg,
                                    yMax: topAvg,
                                    borderColor: '#ff00ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                topLineNeg: {
                                    type: 'line',
                                    yMin: -topAvg,
                                    yMax: -topAvg,
                                    borderColor: '#ff00ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                highLine: {
                                    type: 'line',
                                    yMin: highAvg,
                                    yMax: highAvg,
                                    borderColor: '#ff0000',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                highLineNeg: {
                                    type: 'line',
                                    yMin: -highAvg,
                                    yMax: -highAvg,
                                    borderColor: '#ff0000',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                mediumLine: {
                                    type: 'line',
                                    yMin: mediumAvg,
                                    yMax: mediumAvg,
                                    borderColor: '#ffff00',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                mediumLineNeg: {
                                    type: 'line',
                                    yMin: -mediumAvg,
                                    yMax: -mediumAvg,
                                    borderColor: '#ffff00',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                lowLine: {
                                    type: 'line',
                                    yMin: lowAvg,
                                    yMax: lowAvg,
                                    borderColor: '#4488ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                lowLineNeg: {
                                    type: 'line',
                                    yMin: -lowAvg,
                                    yMax: -lowAvg,
                                    borderColor: '#4488ff',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                zeroLine: {
                                    type: 'line',
                                    yMin: 0,
                                    yMax: 0,
                                    borderColor: '#666666',
                                    borderWidth: 1
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            grid: {
                                color: '#333333'
                            },
                            position: 'left',
                            display: true,
                            ticks: {
                                color: '#ffffff',
                                stepSize: 0.001
                            }
                        },
                        price: {
                            type: 'linear',
                            display: false,
                            position: 'right'
                        },
                        x: {
                            grid: {
                                color: '#333333'
                            },
                            ticks: {
                                color: function(context) {
                                    const label = context.tick.label;
                                    if (label && label.startsWith('Sun')) {
                                        return '#ff4444';
                                    }
                                    return '#ffffff';
                                },
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 1000
                            }
                        }
                    }
                }
            });
        }

        // Update every minute
        updateChart();
        setInterval(updateChart, 60000);
    </script>
</body>
</html>
