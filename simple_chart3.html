<!DOCTYPE html>
<html>
<head>
    <title>BNB Renko Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        .chart-container {
            position: relative;
            width: 90%;
            height: 600px;
            margin: 20px auto;
        }
        canvas {
            background-color: #1a1a1a;
        }
    </style>
</head>
<body style="background-color: #1a1a1a; color: #ffffff;">
    <div class="chart-container">
        <canvas id="renkoChart"></canvas>
        <div id="summary" style="margin-top: 20px; font-family: monospace;"></div>
    </div>

    <script type="module">
        import { getCandles as getBinanceCandles } from './binance.js';
        import { getCandles as getBybitCandles } from './bybit.js';
        import { api, delay } from './config.js';
        
        // Select API based on config
        const getCandles = api === 'binance' ? getBinanceCandles : getBybitCandles;
        import { time, symbol, limit, renkoBlockSize } from './config.js';

        // Function to create Renko blocks from price data with fixed USDT block size
        function createRenkoBlocks(data, blockSizeUSDT) {
            console.log('Creating Renko blocks with data:', data[0], 'Block size:', blockSizeUSDT, 'USDT');
            const blocks = [];
            let currentPrice = parseFloat(data[0].close);
            let lastDirection = null;

            for (let i = 0; i < data.length; i++) {
                const price = parseFloat(data[i].close);
                const priceDiff = price - currentPrice;
                const direction = priceDiff >= 0 ? 1 : -1;

                // Check if price movement is enough to create new block(s)
                if (Math.abs(priceDiff) >= blockSizeUSDT) {
                    const numBlocks = Math.floor(Math.abs(priceDiff) / blockSizeUSDT);
                    
                    for (let j = 0; j < numBlocks; j++) {
                        const blockOpen = currentPrice;
                        const blockClose = currentPrice + (direction * blockSizeUSDT);
                        
                        blocks.push({
                            time: data[i].time,
                            open: blockOpen,
                            close: blockClose,
                            direction: direction,
                            isNewTrend: lastDirection !== null && direction !== lastDirection
                        });
                        
                        currentPrice = blockClose;
                        lastDirection = direction;
                    }
                }
            }

            console.log('Created blocks:', blocks.length);
            return blocks;
        }

        async function updateChart() {
            const endTime = Date.now() - (delay * 60 * 1000);
            const candles = await getCandles(symbol, time, limit, endTime);
            
            // Sort candles by timestamp
            candles.sort((a, b) => new Date(a.time) - new Date(b.time));

            console.log('Raw candles:', candles.length, 'Sample:', candles[0]);
            // Create Renko blocks with fixed USDT block size from config
            const renkoBlocks = createRenkoBlocks(candles, renkoBlockSize);
            console.log('Generated Renko blocks:', renkoBlocks.length);

            // Prepare data for custom Renko display
            // Calculate dynamic block width based on available space
            const calculateBlockDimensions = (chartArea, numBlocks) => {
                const minBlockWidth = 15; // Minimum block width
                const maxBlockWidth = 30; // Maximum block width
                const minSpacing = 1;     // Minimum spacing
                const maxSpacing = 3;     // Maximum spacing

                // Calculate available width per block
                const availableWidth = chartArea.right - chartArea.left;
                let blockWidth = Math.floor(availableWidth / (numBlocks + 5)) - 2; // Add 5 for padding

                // Constrain block width
                blockWidth = Math.max(minBlockWidth, Math.min(blockWidth, maxBlockWidth));
                
                // Adjust spacing based on block width
                const spacing = Math.max(minSpacing, Math.min(maxSpacing, blockWidth * 0.1));

                return { blockWidth, spacing };
            };

            // Create custom plugin for Renko blocks and latest price
            const renkoPlugin = {
                id: 'renkoBlocks',
                beforeDraw: (chart, args, options) => {
                    const {ctx, chartArea, scales} = chart;
                    const blocks = renkoBlocks;
                    const latestPrice = parseFloat(candles[candles.length - 1].close);

                    // Calculate dynamic dimensions
                    const { blockWidth, spacing } = calculateBlockDimensions(chartArea, blocks.length);

                    blocks.forEach((block, i) => {
                        const x = chartArea.left + (i * (blockWidth + spacing));
                        const y = scales.y.getPixelForValue(block.close);
                        const height = Math.abs(scales.y.getPixelForValue(block.open) - y);

                        // Draw block
                        ctx.fillStyle = block.direction > 0 ? '#00ff88' : '#ff4444';
                        ctx.fillRect(x, Math.min(y, scales.y.getPixelForValue(block.open)), blockWidth, height);

                        // Draw trend change indicator
                        if (block.isNewTrend) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x, Math.min(y, scales.y.getPixelForValue(block.open)), blockWidth, height);
                        }

                        // Add block size indicator for multi-block moves
                        const move = Math.abs(block.close - block.open);
                        const blocks = move / renkoBlockSize;
                        if (blocks > 1) {
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(blocks.toString(), x + blockWidth/2, Math.min(y, scales.y.getPixelForValue(block.open)) + height/2);
                        }
                    });

                    // Draw latest price line
                    const y = scales.y.getPixelForValue(latestPrice);
                    ctx.beginPath();
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(chartArea.left, y);
                    ctx.lineTo(chartArea.right, y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Add latest price label
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Latest: $${latestPrice.toFixed(4)}`, chartArea.left + 10, y - 5);
                }
            };

            // Create dataset for price scale
            const dataset = {
                label: 'Renko',
                data: renkoBlocks.map((block, i) => ({
                    x: i,
                    y: block.close
                })),
                borderColor: 'rgba(0,0,0,0)',
                pointRadius: 0
            };

            // Create chart
            const ctx = document.getElementById('renkoChart').getContext('2d');
            if (window.myChart) {
                window.myChart.destroy();
            }

            window.myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [dataset]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    layout: {
                        padding: {
                            left: 20,   // Add padding for price labels
                            right: 50,  // Add padding for last blocks
                            top: 20,    // Add padding for price labels
                            bottom: 20  // Add padding for labels
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            grid: {
                                color: '#333333'
                            },
                            ticks: {
                                color: '#ffffff',
                                callback: function(value) {
                                    return value.toFixed(4);
                                }
                            },
                            beginAtZero: false
                        },
                        x: {
                            type: 'linear',
                            grid: {
                                display: false
                            },
                            ticks: {
                                display: false
                            },
                            offset: true,  // Offset the axis to show full blocks
                            min: -2,      // Add space at start
                            max: renkoBlocks.length + 2  // Add space at end
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const block = renkoBlocks[context.dataIndex];
                                    const move = block.close - block.open;
                                    const moveBlocks = Math.abs(move) / renkoBlockSize;
                                    return [
                                        `Time: ${new Date(block.time).toLocaleTimeString()}`,
                                        `Open: $${block.open.toFixed(4)}`,
                                        `Close: $${block.close.toFixed(4)}`,
                                        `Move: $${Math.abs(move).toFixed(2)} (${moveBlocks} blocks)`,
                                        `Direction: ${move > 0 ? '▲ Up' : '▼ Down'}`
                                    ];
                                }
                            }
                        },
                        renkoBlocks: {}
                    }
                },
                plugins: [renkoPlugin]
            });
        }

        // Update every minute
        updateChart();
        setInterval(updateChart, 60000);
    </script>
</body>
</html>
